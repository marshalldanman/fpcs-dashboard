<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SentryLion // Network Defense System</title>
<style>
/* ═══════════════════════════════════════════════════════════
   SENTRYLION — NETWORK DEFENSE CONSOLE
   Deep Space / Cyberpunk Command Center
   ═══════════════════════════════════════════════════════════ */

@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --bg-deep: #0a0e1a;
  --bg-panel: #0d1225;
  --bg-panel-border: #1a2340;
  --amber: #f59e0b;
  --amber-dark: #d97706;
  --amber-glow: rgba(245, 158, 11, 0.3);
  --cyan: #38bdf8;
  --cyan-dark: #0ea5e9;
  --cyan-glow: rgba(56, 189, 248, 0.3);
  --green: #22c55e;
  --green-glow: rgba(34, 197, 94, 0.3);
  --red: #ef4444;
  --red-glow: rgba(239, 68, 68, 0.4);
  --yellow: #eab308;
  --text-primary: #e2e8f0;
  --text-dim: #64748b;
  --text-bright: #f8fafc;
  --grid-line: rgba(56, 189, 248, 0.06);
  --scanline-color: rgba(56, 189, 248, 0.03);
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg-deep);
  color: var(--text-primary);
  font-family: 'Share Tech Mono', monospace;
}

/* ── SCAN LINE OVERLAY ────────────────────────────────── */
body::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.03) 2px,
    rgba(0, 0, 0, 0.03) 4px
  );
  pointer-events: none;
  z-index: 9998;
}

/* Moving scan line */
body::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 4px;
  background: linear-gradient(180deg,
    transparent,
    var(--scanline-color),
    rgba(56, 189, 248, 0.08),
    var(--scanline-color),
    transparent
  );
  animation: scanline 4s linear infinite;
  pointer-events: none;
  z-index: 9999;
}

@keyframes scanline {
  0% { top: -4px; }
  100% { top: 100%; }
}

/* ── GRID BACKGROUND ──────────────────────────────────── */
#grid-bg {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background-image:
    linear-gradient(var(--grid-line) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
  background-size: 40px 40px;
  pointer-events: none;
  z-index: 0;
}

/* ── CORNER BRACKETS (LCARS-style) ────────────────────── */
.corner-bracket {
  position: fixed;
  width: 40px;
  height: 40px;
  z-index: 10;
  pointer-events: none;
}
.corner-bracket.tl { top: 8px; left: 8px; border-top: 2px solid var(--amber); border-left: 2px solid var(--amber); }
.corner-bracket.tr { top: 8px; right: 8px; border-top: 2px solid var(--amber); border-right: 2px solid var(--amber); }
.corner-bracket.bl { bottom: 8px; left: 8px; border-bottom: 2px solid var(--amber); border-left: 2px solid var(--amber); }
.corner-bracket.br { bottom: 8px; right: 8px; border-bottom: 2px solid var(--amber); border-right: 2px solid var(--amber); }

/* ── MAIN LAYOUT ──────────────────────────────────────── */
#app {
  display: grid;
  grid-template-rows: 48px 1fr 180px;
  grid-template-columns: 280px 1fr 280px;
  grid-template-areas:
    "top    top    top"
    "left   center right"
    "bottom bottom controls";
  width: 100vw;
  height: 100vh;
  gap: 4px;
  padding: 4px;
  position: relative;
  z-index: 1;
}

/* ── PANELS ───────────────────────────────────────────── */
.panel {
  background: var(--bg-panel);
  border: 1px solid var(--bg-panel-border);
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.panel::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--amber-glow), transparent);
}

.panel-label {
  position: absolute;
  top: 6px;
  left: 10px;
  font-family: 'Orbitron', monospace;
  font-size: 9px;
  font-weight: 700;
  color: var(--amber);
  letter-spacing: 2px;
  text-transform: uppercase;
  opacity: 0.8;
}

/* ════════════════════════════════════════════════════════
   TOP BAR
   ════════════════════════════════════════════════════════ */
#top-bar {
  grid-area: top;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  background: linear-gradient(180deg, #0f1630, var(--bg-panel));
  border-bottom: 1px solid var(--bg-panel-border);
}

#top-bar .title {
  font-family: 'Orbitron', monospace;
  font-size: 16px;
  font-weight: 900;
  letter-spacing: 3px;
  background: linear-gradient(90deg, var(--amber), var(--cyan));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#top-bar .status-group {
  display: flex;
  align-items: center;
  gap: 20px;
}

.status-badge {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 11px;
  letter-spacing: 1px;
  color: var(--green);
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--green);
  animation: pulse-dot 1.5s ease-in-out infinite;
}

@keyframes pulse-dot {
  0%, 100% { box-shadow: 0 0 4px var(--green-glow); }
  50% { box-shadow: 0 0 12px var(--green), 0 0 24px var(--green-glow); }
}

#clock {
  font-family: 'Share Tech Mono', monospace;
  font-size: 13px;
  color: var(--cyan);
  letter-spacing: 1px;
}

#back-btn {
  background: none;
  border: 1px solid var(--amber-dark);
  color: var(--amber);
  font-family: 'Orbitron', monospace;
  font-size: 10px;
  padding: 4px 12px;
  cursor: pointer;
  letter-spacing: 1px;
  border-radius: 2px;
  transition: all 0.2s;
}

#back-btn:hover {
  background: var(--amber-glow);
  box-shadow: 0 0 10px var(--amber-glow);
}

/* ════════════════════════════════════════════════════════
   LEFT PANEL — THREAT RADAR
   ════════════════════════════════════════════════════════ */
#left-panel {
  grid-area: left;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 28px;
}

#radar-container {
  position: relative;
  width: 240px;
  height: 240px;
  margin-top: 8px;
}

#radar-canvas {
  width: 240px;
  height: 240px;
}

#radar-center-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  pointer-events: none;
}

#threat-count {
  font-family: 'Orbitron', monospace;
  font-size: 32px;
  font-weight: 900;
  color: var(--amber);
  text-shadow: 0 0 20px var(--amber-glow);
  line-height: 1;
}

#threat-label {
  font-size: 9px;
  color: var(--text-dim);
  letter-spacing: 2px;
  margin-top: 2px;
}

#threat-list {
  width: 100%;
  padding: 12px 10px;
  flex: 1;
  overflow: hidden;
}

#threat-list .threat-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 10px;
  padding: 3px 0;
  color: var(--text-dim);
  animation: fadeInItem 0.3s ease;
}

@keyframes fadeInItem {
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
}

.threat-item .dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}

.threat-item .dot.safe { background: var(--green); box-shadow: 0 0 4px var(--green-glow); }
.threat-item .dot.suspicious { background: var(--yellow); box-shadow: 0 0 4px rgba(234, 179, 8, 0.4); }
.threat-item .dot.threat { background: var(--red); box-shadow: 0 0 4px var(--red-glow); }

/* ════════════════════════════════════════════════════════
   CENTER PANEL — NETWORK TOPOLOGY
   ════════════════════════════════════════════════════════ */
#center-panel {
  grid-area: center;
  position: relative;
}

#network-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

#ai-confidence-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  pointer-events: none;
}

#ai-confidence-value {
  font-family: 'Orbitron', monospace;
  font-size: 48px;
  font-weight: 900;
  color: var(--cyan);
  text-shadow: 0 0 30px var(--cyan-glow), 0 0 60px rgba(56, 189, 248, 0.15);
  line-height: 1;
}

#ai-confidence-label {
  font-family: 'Orbitron', monospace;
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 4px;
  margin-top: 4px;
}

/* Sonar pulse from center */
.sonar-pulse {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 1px solid var(--cyan);
  animation: sonar-expand 3s ease-out infinite;
  pointer-events: none;
}

.sonar-pulse:nth-child(2) { animation-delay: 1s; }
.sonar-pulse:nth-child(3) { animation-delay: 2s; }

@keyframes sonar-expand {
  0% { width: 20px; height: 20px; opacity: 0.6; }
  100% { width: 400px; height: 400px; opacity: 0; }
}

/* ════════════════════════════════════════════════════════
   RIGHT PANEL — DIALS & GAUGES
   ════════════════════════════════════════════════════════ */
#right-panel {
  grid-area: right;
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 24px 8px 8px;
  overflow-y: auto;
}

.gauge-container {
  flex: 1;
  min-height: 100px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.gauge-container svg {
  width: 100%;
  max-width: 200px;
  height: auto;
}

.gauge-label {
  font-family: 'Orbitron', monospace;
  font-size: 8px;
  letter-spacing: 2px;
  color: var(--amber);
  text-align: center;
  margin-top: 2px;
}

.gauge-value {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 700;
  color: var(--text-bright);
  text-align: center;
  text-shadow: 0 0 8px var(--cyan-glow);
}

/* ════════════════════════════════════════════════════════
   BOTTOM PANEL — LIVE LOG FEED
   ════════════════════════════════════════════════════════ */
#bottom-panel {
  grid-area: bottom;
  padding: 24px 12px 8px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#log-feed {
  flex: 1;
  overflow-y: auto;
  font-family: 'Share Tech Mono', monospace;
  font-size: 11px;
  line-height: 1.6;
  scrollbar-width: thin;
  scrollbar-color: var(--bg-panel-border) transparent;
}

#log-feed::-webkit-scrollbar { width: 4px; }
#log-feed::-webkit-scrollbar-track { background: transparent; }
#log-feed::-webkit-scrollbar-thumb { background: var(--bg-panel-border); border-radius: 2px; }

.log-entry {
  animation: logSlide 0.3s ease;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

@keyframes logSlide {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.log-entry .ts { color: var(--text-dim); }
.log-entry .tag-scan { color: var(--cyan); }
.log-entry .tag-ai { color: #a78bfa; }
.log-entry .tag-allow { color: var(--green); }
.log-entry .tag-block { color: var(--red); }
.log-entry .tag-shield { color: var(--amber); }
.log-entry .tag-warn { color: var(--yellow); }
.log-entry .msg { color: #94a3b8; }

/* ════════════════════════════════════════════════════════
   CONTROLS PANEL — LEVERS & SWITCHES
   ════════════════════════════════════════════════════════ */
#controls-panel {
  grid-area: controls;
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 24px 12px 10px;
}

.lever-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.lever-label {
  font-family: 'Orbitron', monospace;
  font-size: 8px;
  color: var(--amber);
  letter-spacing: 2px;
}

.lever-track {
  position: relative;
  height: 24px;
  background: #111832;
  border: 1px solid var(--bg-panel-border);
  border-radius: 3px;
  cursor: pointer;
  overflow: hidden;
}

.lever-track::before {
  content: '';
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: var(--lever-pct, 33%);
  background: linear-gradient(90deg, var(--amber-dark), var(--amber));
  border-radius: 2px;
  transition: width 0.3s ease;
  box-shadow: 0 0 10px var(--amber-glow);
}

.lever-value {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px;
  color: var(--text-bright);
  z-index: 2;
  letter-spacing: 1px;
  pointer-events: none;
}

/* Mode toggle switch */
.toggle-group {
  display: flex;
  gap: 2px;
}

.toggle-btn {
  flex: 1;
  padding: 4px 2px;
  font-family: 'Orbitron', monospace;
  font-size: 7px;
  letter-spacing: 1px;
  background: #111832;
  border: 1px solid var(--bg-panel-border);
  color: var(--text-dim);
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.toggle-btn.active {
  background: linear-gradient(180deg, var(--amber-dark), #92400e);
  color: var(--text-bright);
  border-color: var(--amber);
  box-shadow: 0 0 8px var(--amber-glow);
}

.toggle-btn:hover:not(.active) {
  border-color: var(--amber-dark);
  color: var(--text-primary);
}

/* Flip switch */
.flip-switch {
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
}

.flip-track {
  width: 40px;
  height: 18px;
  background: #111832;
  border: 1px solid var(--bg-panel-border);
  border-radius: 9px;
  position: relative;
  transition: all 0.3s;
}

.flip-track.on {
  border-color: var(--cyan-dark);
  box-shadow: 0 0 10px var(--cyan-glow);
}

.flip-knob {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--text-dim);
  transition: all 0.3s;
}

.flip-track.on .flip-knob {
  left: 24px;
  background: var(--cyan);
  box-shadow: 0 0 6px var(--cyan-glow);
}

.flip-label {
  font-size: 10px;
  color: var(--text-dim);
  letter-spacing: 1px;
}

.flip-label.on { color: var(--cyan); }

/* ════════════════════════════════════════════════════════
   PARTICLES CANVAS
   ════════════════════════════════════════════════════════ */
#particles-canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 2;
}

/* ════════════════════════════════════════════════════════
   THREAT FLASH OVERLAY
   ════════════════════════════════════════════════════════ */
#threat-flash {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--red-glow);
  pointer-events: none;
  opacity: 0;
  z-index: 9000;
  transition: opacity 0.1s;
}

#threat-flash.active {
  animation: threatFlash 0.6s ease;
}

@keyframes threatFlash {
  0% { opacity: 0.35; }
  20% { opacity: 0; }
  40% { opacity: 0.2; }
  60% { opacity: 0; }
  80% { opacity: 0.1; }
  100% { opacity: 0; }
}

/* ════════════════════════════════════════════════════════
   RESPONSIVE
   ════════════════════════════════════════════════════════ */
@media (max-width: 1100px) {
  #app {
    grid-template-columns: 220px 1fr 220px;
  }
}

@media (max-width: 860px) {
  #app {
    grid-template-columns: 1fr;
    grid-template-rows: 48px 280px 300px auto 180px;
    grid-template-areas:
      "top"
      "left"
      "center"
      "right"
      "bottom";
    height: auto;
    min-height: 100vh;
    overflow-y: auto;
  }
  #controls-panel {
    grid-area: unset;
  }
  body { overflow-y: auto; }
  #right-panel {
    flex-direction: row;
    flex-wrap: wrap;
    padding: 24px 8px 8px;
  }
  .gauge-container {
    width: 48%;
    min-height: 130px;
  }
}
</style>
</head>
<body>

<!-- Grid background -->
<div id="grid-bg"></div>

<!-- Corner brackets -->
<div class="corner-bracket tl"></div>
<div class="corner-bracket tr"></div>
<div class="corner-bracket bl"></div>
<div class="corner-bracket br"></div>

<!-- Floating particles -->
<canvas id="particles-canvas"></canvas>

<!-- Threat flash overlay -->
<div id="threat-flash"></div>

<!-- ═══════════ MAIN APP GRID ═══════════ -->
<div id="app">

  <!-- ── TOP BAR ──────────────────────── -->
  <div id="top-bar">
    <button id="back-btn" onclick="goBack()" title="Return to Dashboard (ESC)">&lt; EXIT</button>
    <div class="title">SENTRYLION // NETWORK DEFENSE SYSTEM</div>
    <div class="status-group">
      <div class="status-badge">
        <div class="status-dot"></div>
        <span>ACTIVE</span>
      </div>
      <div id="clock">00:00:00.000</div>
    </div>
  </div>

  <!-- ── LEFT: THREAT RADAR ───────────── -->
  <div id="left-panel" class="panel">
    <div class="panel-label">THREAT RADAR</div>
    <div id="radar-container">
      <canvas id="radar-canvas" width="480" height="480"></canvas>
      <div id="radar-center-text">
        <div id="threat-count">0</div>
        <div id="threat-label">THREATS</div>
      </div>
    </div>
    <div id="threat-list"></div>
  </div>

  <!-- ── CENTER: NETWORK TOPOLOGY ─────── -->
  <div id="center-panel" class="panel">
    <div class="panel-label">NETWORK TOPOLOGY</div>
    <canvas id="network-canvas"></canvas>
    <div class="sonar-pulse"></div>
    <div class="sonar-pulse"></div>
    <div class="sonar-pulse"></div>
    <div id="ai-confidence-overlay">
      <div id="ai-confidence-value">97.3%</div>
      <div id="ai-confidence-label">AI CONFIDENCE</div>
    </div>
  </div>

  <!-- ── RIGHT: GAUGES ────────────────── -->
  <div id="right-panel" class="panel">
    <div class="panel-label">SYSTEM GAUGES</div>

    <!-- Gauge 1: Bandwidth -->
    <div class="gauge-container" id="gauge-bandwidth">
      <svg viewBox="0 0 200 120"></svg>
      <div class="gauge-value" id="gv-bandwidth">0 Mbps</div>
      <div class="gauge-label">BANDWIDTH</div>
    </div>

    <!-- Gauge 2: Threat Level -->
    <div class="gauge-container" id="gauge-threat">
      <svg viewBox="0 0 200 120"></svg>
      <div class="gauge-value" id="gv-threat">LOW</div>
      <div class="gauge-label">THREAT LEVEL</div>
    </div>

    <!-- Gauge 3: Firewall Load -->
    <div class="gauge-container" id="gauge-firewall">
      <svg viewBox="0 0 200 120"></svg>
      <div class="gauge-value" id="gv-firewall">0%</div>
      <div class="gauge-label">FIREWALL LOAD</div>
    </div>

    <!-- Gauge 4: Encryption -->
    <div class="gauge-container" id="gauge-encryption">
      <svg viewBox="0 0 200 120"></svg>
      <div class="gauge-value" id="gv-encryption">256-BIT</div>
      <div class="gauge-label">ENCRYPTION</div>
    </div>
  </div>

  <!-- ── BOTTOM: LIVE LOG FEED ────────── -->
  <div id="bottom-panel" class="panel">
    <div class="panel-label">LIVE FEED</div>
    <div id="log-feed"></div>
  </div>

  <!-- ── CONTROLS: LEVERS ─────────────── -->
  <div id="controls-panel" class="panel">
    <div class="panel-label">CONTROLS</div>

    <!-- Sensitivity Lever -->
    <div class="lever-group">
      <div class="lever-label">SENSITIVITY</div>
      <div class="lever-track" id="lever-sensitivity" style="--lever-pct: 33%;" onclick="cycleSensitivity()">
        <div class="lever-value" id="sensitivity-val">MEDIUM</div>
      </div>
    </div>

    <!-- Mode Toggle -->
    <div class="lever-group">
      <div class="lever-label">MODE</div>
      <div class="toggle-group" id="mode-toggles">
        <div class="toggle-btn active" data-mode="monitor" onclick="setMode(this)">MONITOR</div>
        <div class="toggle-btn" data-mode="defense" onclick="setMode(this)">DEFENSE</div>
        <div class="toggle-btn" data-mode="lockdown" onclick="setMode(this)">LOCKDOWN</div>
      </div>
    </div>

    <!-- AI Override Flip -->
    <div class="lever-group">
      <div class="lever-label">AI OVERRIDE</div>
      <div class="flip-switch" onclick="toggleAI()">
        <div class="flip-track" id="ai-track">
          <div class="flip-knob"></div>
        </div>
        <div class="flip-label" id="ai-label">AUTO</div>
      </div>
    </div>
  </div>

</div>

<script>
/* ═══════════════════════════════════════════════════════════
   SENTRYLION ENGINE
   ═══════════════════════════════════════════════════════════ */

// ── STATE ────────────────────────────────────────────────
const state = {
  sensitivity: 1, // 0=Low, 1=Med, 2=High, 3=Paranoid
  sensLabels: ['LOW', 'MEDIUM', 'HIGH', 'PARANOID'],
  sensPcts: ['10%', '33%', '66%', '100%'],
  mode: 'monitor',
  aiOverride: false,
  threatCount: 0,
  confidence: 97.3,
  bandwidth: 420,
  threatLevel: 15,
  firewallLoad: 34,
  encryptionIdx: 1, // 0=128, 1=256, 2=512
  encLabels: ['128-BIT', '256-BIT', '512-BIT'],
  radarBlips: [],
  networkNodes: [],
  particles: [],
  logEntries: [],
  threats: [],
  lastThreatTime: 0,
};

// ── BACK BUTTON ──────────────────────────────────────────
function goBack() {
  if (document.referrer && document.referrer.includes('realbotville')) {
    window.location.href = 'realbotville.html';
  } else {
    window.location.href = 'index.html';
  }
}
document.addEventListener('keydown', e => { if (e.key === 'Escape') goBack(); });

// ── CLOCK ────────────────────────────────────────────────
function updateClock() {
  const now = new Date();
  const h = String(now.getHours()).padStart(2, '0');
  const m = String(now.getMinutes()).padStart(2, '0');
  const s = String(now.getSeconds()).padStart(2, '0');
  const ms = String(now.getMilliseconds()).padStart(3, '0');
  document.getElementById('clock').textContent = `${h}:${m}:${s}.${ms}`;
}

// ── CONTROLS ─────────────────────────────────────────────
function cycleSensitivity() {
  state.sensitivity = (state.sensitivity + 1) % 4;
  const track = document.getElementById('lever-sensitivity');
  track.style.setProperty('--lever-pct', state.sensPcts[state.sensitivity]);
  document.getElementById('sensitivity-val').textContent = state.sensLabels[state.sensitivity];
  addLog('SHIELD', `Sensitivity set to ${state.sensLabels[state.sensitivity]}`);
}

function setMode(btn) {
  document.querySelectorAll('#mode-toggles .toggle-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  state.mode = btn.dataset.mode;
  addLog('SHIELD', `Mode changed to ${state.mode.toUpperCase()}`);
}

function toggleAI() {
  state.aiOverride = !state.aiOverride;
  const track = document.getElementById('ai-track');
  const label = document.getElementById('ai-label');
  track.classList.toggle('on', !state.aiOverride);
  label.classList.toggle('on', !state.aiOverride);
  label.textContent = state.aiOverride ? 'MANUAL' : 'AUTO';
  addLog('AI', `Override set to ${state.aiOverride ? 'MANUAL' : 'AUTO'}`);
}

// ═══════════════════════════════════════════════════════════
// RADAR
// ═══════════════════════════════════════════════════════════
const radarCanvas = document.getElementById('radar-canvas');
const radarCtx = radarCanvas.getContext('2d');
let radarAngle = 0;

function initRadarBlips() {
  for (let i = 0; i < 5; i++) spawnBlip('safe');
}

function spawnBlip(type) {
  const angle = Math.random() * Math.PI * 2;
  const dist = 0.2 + Math.random() * 0.75;
  state.radarBlips.push({
    x: Math.cos(angle) * dist,
    y: Math.sin(angle) * dist,
    type, // safe, suspicious, threat
    alpha: 1,
    born: Date.now(),
    life: 8000 + Math.random() * 12000,
  });
}

function drawRadar(now) {
  const w = radarCanvas.width, h = radarCanvas.height;
  const cx = w / 2, cy = h / 2, r = w / 2 - 16;
  radarCtx.clearRect(0, 0, w, h);

  // Rings
  const rings = [0.33, 0.66, 1.0];
  const ringLabels = ['CORE', 'INTERNAL', 'PERIMETER'];
  radarCtx.strokeStyle = 'rgba(56, 189, 248, 0.12)';
  radarCtx.lineWidth = 1;
  rings.forEach((pct, i) => {
    radarCtx.beginPath();
    radarCtx.arc(cx, cy, r * pct, 0, Math.PI * 2);
    radarCtx.stroke();
    // label
    radarCtx.fillStyle = 'rgba(56, 189, 248, 0.25)';
    radarCtx.font = '10px "Share Tech Mono"';
    radarCtx.fillText(ringLabels[i], cx + r * pct * 0.5, cy - r * pct + 14);
  });

  // Cross lines
  radarCtx.strokeStyle = 'rgba(56, 189, 248, 0.08)';
  radarCtx.beginPath();
  radarCtx.moveTo(cx, cy - r); radarCtx.lineTo(cx, cy + r);
  radarCtx.moveTo(cx - r, cy); radarCtx.lineTo(cx + r, cy);
  radarCtx.stroke();

  // Sweep
  radarAngle += 0.02;
  const sweepGrad = radarCtx.createConicalGradient
    ? null
    : null; // fallback

  // Draw sweep cone
  radarCtx.save();
  radarCtx.translate(cx, cy);
  radarCtx.rotate(radarAngle);
  const grad = radarCtx.createLinearGradient(0, 0, r, 0);
  grad.addColorStop(0, 'rgba(56, 189, 248, 0.25)');
  grad.addColorStop(1, 'rgba(56, 189, 248, 0.02)');
  radarCtx.fillStyle = grad;
  radarCtx.beginPath();
  radarCtx.moveTo(0, 0);
  radarCtx.arc(0, 0, r, -0.3, 0);
  radarCtx.closePath();
  radarCtx.fill();
  // Sweep line
  radarCtx.strokeStyle = 'rgba(56, 189, 248, 0.6)';
  radarCtx.lineWidth = 2;
  radarCtx.beginPath();
  radarCtx.moveTo(0, 0);
  radarCtx.lineTo(r, 0);
  radarCtx.stroke();
  radarCtx.restore();

  // Blips
  const colors = { safe: '#22c55e', suspicious: '#eab308', threat: '#ef4444' };
  const glows = { safe: 'rgba(34,197,94,0.5)', suspicious: 'rgba(234,179,8,0.5)', threat: 'rgba(239,68,68,0.6)' };

  state.radarBlips = state.radarBlips.filter(b => {
    const age = now - b.born;
    if (age > b.life) return false;
    b.alpha = Math.max(0, 1 - age / b.life);
    return true;
  });

  state.radarBlips.forEach(b => {
    const bx = cx + b.x * r;
    const by = cy + b.y * r;
    radarCtx.globalAlpha = b.alpha;
    radarCtx.fillStyle = glows[b.type];
    radarCtx.beginPath();
    radarCtx.arc(bx, by, 6, 0, Math.PI * 2);
    radarCtx.fill();
    radarCtx.fillStyle = colors[b.type];
    radarCtx.beginPath();
    radarCtx.arc(bx, by, 3, 0, Math.PI * 2);
    radarCtx.fill();
    radarCtx.globalAlpha = 1;
  });

  // Update threat count
  const activeThreats = state.radarBlips.filter(b => b.type === 'threat').length;
  state.threatCount = activeThreats;
  document.getElementById('threat-count').textContent = activeThreats;
  document.getElementById('threat-count').style.color = activeThreats > 0 ? '#ef4444' : '#f59e0b';
}

// ═══════════════════════════════════════════════════════════
// NETWORK TOPOLOGY (Center Canvas)
// ═══════════════════════════════════════════════════════════
const netCanvas = document.getElementById('network-canvas');
const netCtx = netCanvas.getContext('2d');
let netTime = 0;

const deviceNames = ['Server-A', 'Workstation-1', 'NAS', 'IoT-Hub', 'Mobile-7', 'Printer', 'Camera-3', 'AP-Main', 'DB-Primary', 'Switch-Core'];
const deviceIcons = ['S', 'W', 'N', 'I', 'M', 'P', 'C', 'A', 'D', 'X'];

function initNetworkNodes() {
  const count = 10;
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
    const orbitR = 0.32;
    state.networkNodes.push({
      angle,
      orbitR,
      orbitSpeed: 0.0005 + Math.random() * 0.001,
      name: deviceNames[i],
      icon: deviceIcons[i],
      pulse: Math.random() * Math.PI * 2,
      active: true,
      threat: false,
      particles: [],
    });
  }
}

function resizeNetCanvas() {
  const rect = netCanvas.parentElement.getBoundingClientRect();
  netCanvas.width = rect.width * window.devicePixelRatio;
  netCanvas.height = rect.height * window.devicePixelRatio;
  netCanvas.style.width = rect.width + 'px';
  netCanvas.style.height = rect.height + 'px';
  netCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
}

function drawNetwork(now) {
  const w = netCanvas.width / window.devicePixelRatio;
  const h = netCanvas.height / window.devicePixelRatio;
  const cx = w / 2, cy = h / 2;
  const baseR = Math.min(w, h) * 0.38;
  netCtx.clearRect(0, 0, w, h);
  netTime += 0.016;

  // Outer ring decoration
  netCtx.strokeStyle = 'rgba(56, 189, 248, 0.08)';
  netCtx.lineWidth = 1;
  netCtx.beginPath();
  netCtx.arc(cx, cy, baseR + 20, 0, Math.PI * 2);
  netCtx.stroke();

  netCtx.strokeStyle = 'rgba(245, 158, 11, 0.06)';
  netCtx.setLineDash([4, 8]);
  netCtx.beginPath();
  netCtx.arc(cx, cy, baseR + 35, 0, Math.PI * 2);
  netCtx.stroke();
  netCtx.setLineDash([]);

  // Central router
  const routerPulse = 0.8 + 0.2 * Math.sin(netTime * 2);
  netCtx.fillStyle = `rgba(56, 189, 248, ${0.1 * routerPulse})`;
  netCtx.beginPath();
  netCtx.arc(cx, cy, 30, 0, Math.PI * 2);
  netCtx.fill();
  netCtx.strokeStyle = `rgba(56, 189, 248, ${0.5 * routerPulse})`;
  netCtx.lineWidth = 2;
  netCtx.beginPath();
  netCtx.arc(cx, cy, 22, 0, Math.PI * 2);
  netCtx.stroke();
  netCtx.fillStyle = '#38bdf8';
  netCtx.font = 'bold 12px "Orbitron"';
  netCtx.textAlign = 'center';
  netCtx.textBaseline = 'middle';
  netCtx.fillText('R', cx, cy);

  // Nodes
  state.networkNodes.forEach((node, i) => {
    node.angle += node.orbitSpeed;
    node.pulse += 0.03;
    const nx = cx + Math.cos(node.angle) * baseR;
    const ny = cy + Math.sin(node.angle) * baseR;

    // Connection line
    const lineAlpha = 0.15 + 0.1 * Math.sin(node.pulse);
    netCtx.strokeStyle = node.threat
      ? `rgba(239, 68, 68, ${lineAlpha + 0.2})`
      : `rgba(56, 189, 248, ${lineAlpha})`;
    netCtx.lineWidth = 1;
    netCtx.beginPath();
    netCtx.moveTo(cx, cy);
    netCtx.lineTo(nx, ny);
    netCtx.stroke();

    // Data flow particles on lines
    const particleCount = 2;
    for (let p = 0; p < particleCount; p++) {
      const t = ((netTime * 0.3 + p * 0.5 + i * 0.1) % 1);
      const px = cx + (nx - cx) * t;
      const py = cy + (ny - cy) * t;
      const pAlpha = Math.sin(t * Math.PI) * 0.8;
      netCtx.fillStyle = node.threat
        ? `rgba(239, 68, 68, ${pAlpha})`
        : `rgba(56, 189, 248, ${pAlpha})`;
      netCtx.beginPath();
      netCtx.arc(px, py, 2, 0, Math.PI * 2);
      netCtx.fill();
    }

    // Node glow
    const glow = 0.15 + 0.1 * Math.sin(node.pulse);
    netCtx.fillStyle = node.threat
      ? `rgba(239, 68, 68, ${glow})`
      : `rgba(56, 189, 248, ${glow})`;
    netCtx.beginPath();
    netCtx.arc(nx, ny, 18, 0, Math.PI * 2);
    netCtx.fill();

    // Node circle
    netCtx.strokeStyle = node.threat ? '#ef4444' : 'rgba(56, 189, 248, 0.6)';
    netCtx.lineWidth = 1.5;
    netCtx.beginPath();
    netCtx.arc(nx, ny, 12, 0, Math.PI * 2);
    netCtx.stroke();

    // Node fill
    netCtx.fillStyle = node.threat ? 'rgba(239, 68, 68, 0.15)' : 'rgba(56, 189, 248, 0.08)';
    netCtx.beginPath();
    netCtx.arc(nx, ny, 12, 0, Math.PI * 2);
    netCtx.fill();

    // Node letter
    netCtx.fillStyle = node.threat ? '#ef4444' : '#38bdf8';
    netCtx.font = '9px "Orbitron"';
    netCtx.textAlign = 'center';
    netCtx.textBaseline = 'middle';
    netCtx.fillText(node.icon, nx, ny);

    // Node name
    netCtx.fillStyle = 'rgba(148, 163, 184, 0.6)';
    netCtx.font = '8px "Share Tech Mono"';
    netCtx.fillText(node.name, nx, ny + 22);
  });
}

// ═══════════════════════════════════════════════════════════
// SVG GAUGES
// ═══════════════════════════════════════════════════════════
function createGaugeSVG(containerId, min, max, zones, unit) {
  const svg = document.querySelector(`#${containerId} svg`);
  const cx = 100, cy = 95, r = 75;
  const startAngle = Math.PI * 0.8;
  const endAngle = Math.PI * 0.2;
  const sweep = Math.PI * 1.6; // total arc

  let markup = '';

  // Background arc
  markup += describeArc(cx, cy, r, startAngle, startAngle + sweep, 'rgba(30,40,70,0.5)', 8, `${containerId}-bg`);

  // Zone arcs
  if (zones) {
    zones.forEach(z => {
      const a1 = startAngle + sweep * ((z.from - min) / (max - min));
      const a2 = startAngle + sweep * ((z.to - min) / (max - min));
      markup += describeArc(cx, cy, r, a1, a2, z.color, 6, '');
    });
  }

  // Tick marks
  const tickCount = 10;
  for (let i = 0; i <= tickCount; i++) {
    const a = startAngle + sweep * (i / tickCount);
    const x1 = cx + Math.cos(a) * (r - 10);
    const y1 = cy + Math.sin(a) * (r - 10);
    const x2 = cx + Math.cos(a) * (r + 2);
    const y2 = cy + Math.sin(a) * (r + 2);
    markup += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(148,163,184,0.3)" stroke-width="1"/>`;
    // Number
    const val = Math.round(min + (max - min) * (i / tickCount));
    const tx = cx + Math.cos(a) * (r - 20);
    const ty = cy + Math.sin(a) * (r - 20);
    markup += `<text x="${tx}" y="${ty}" fill="rgba(148,163,184,0.4)" font-size="7" font-family="Share Tech Mono" text-anchor="middle" dominant-baseline="middle">${val}</text>`;
  }

  // Needle
  markup += `<line id="${containerId}-needle" x1="${cx}" y1="${cy}" x2="${cx + Math.cos(startAngle) * (r - 14)}" y2="${cy + Math.sin(startAngle) * (r - 14)}" stroke="#f59e0b" stroke-width="2" stroke-linecap="round"/>`;
  // Center dot
  markup += `<circle cx="${cx}" cy="${cy}" r="4" fill="#f59e0b"/>`;
  markup += `<circle cx="${cx}" cy="${cy}" r="2" fill="#0a0e1a"/>`;

  svg.innerHTML = markup;

  return { cx, cy, r, startAngle, sweep, min, max, needleId: `${containerId}-needle` };
}

function describeArc(cx, cy, r, startA, endA, color, width, id) {
  const x1 = cx + Math.cos(startA) * r;
  const y1 = cy + Math.sin(startA) * r;
  const x2 = cx + Math.cos(endA) * r;
  const y2 = cy + Math.sin(endA) * r;
  const largeArc = (endA - startA) > Math.PI ? 1 : 0;
  const idAttr = id ? `id="${id}"` : '';
  return `<path ${idAttr} d="M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2}" fill="none" stroke="${color}" stroke-width="${width}" stroke-linecap="round"/>`;
}

function updateNeedle(gaugeInfo, value) {
  const pct = Math.max(0, Math.min(1, (value - gaugeInfo.min) / (gaugeInfo.max - gaugeInfo.min)));
  const angle = gaugeInfo.startAngle + gaugeInfo.sweep * pct;
  const nx = gaugeInfo.cx + Math.cos(angle) * (gaugeInfo.r - 14);
  const ny = gaugeInfo.cy + Math.sin(angle) * (gaugeInfo.r - 14);
  const needle = document.getElementById(gaugeInfo.needleId);
  if (needle) {
    needle.setAttribute('x2', nx);
    needle.setAttribute('y2', ny);
  }
}

// Initialize gauges
let gaugeBandwidth, gaugeThreat, gaugeFirewall, gaugeEncryption;

function initGauges() {
  gaugeBandwidth = createGaugeSVG('gauge-bandwidth', 0, 1000, [
    { from: 0, to: 400, color: 'rgba(34,197,94,0.4)' },
    { from: 400, to: 700, color: 'rgba(56,189,248,0.4)' },
    { from: 700, to: 1000, color: 'rgba(245,158,11,0.4)' },
  ]);

  gaugeThreat = createGaugeSVG('gauge-threat', 0, 100, [
    { from: 0, to: 25, color: 'rgba(34,197,94,0.5)' },
    { from: 25, to: 50, color: 'rgba(234,179,8,0.5)' },
    { from: 50, to: 75, color: 'rgba(245,158,11,0.5)' },
    { from: 75, to: 100, color: 'rgba(239,68,68,0.5)' },
  ]);

  gaugeFirewall = createGaugeSVG('gauge-firewall', 0, 100, [
    { from: 0, to: 60, color: 'rgba(34,197,94,0.4)' },
    { from: 60, to: 85, color: 'rgba(234,179,8,0.4)' },
    { from: 85, to: 100, color: 'rgba(239,68,68,0.4)' },
  ]);

  gaugeEncryption = createGaugeSVG('gauge-encryption', 0, 3, [
    { from: 0, to: 1, color: 'rgba(234,179,8,0.4)' },
    { from: 1, to: 2, color: 'rgba(56,189,248,0.4)' },
    { from: 2, to: 3, color: 'rgba(34,197,94,0.5)' },
  ]);
}

function updateGauges() {
  // Bandwidth fluctuates
  state.bandwidth += (Math.random() - 0.48) * 30;
  state.bandwidth = Math.max(80, Math.min(950, state.bandwidth));
  updateNeedle(gaugeBandwidth, state.bandwidth);
  document.getElementById('gv-bandwidth').textContent = Math.round(state.bandwidth) + ' Mbps';

  // Threat level
  state.threatLevel += (Math.random() - 0.5) * 5;
  state.threatLevel = Math.max(2, Math.min(95, state.threatLevel));
  updateNeedle(gaugeThreat, state.threatLevel);
  const tl = state.threatLevel;
  const tlLabel = tl < 25 ? 'LOW' : tl < 50 ? 'MODERATE' : tl < 75 ? 'HIGH' : 'CRITICAL';
  const tlColor = tl < 25 ? '#22c55e' : tl < 50 ? '#eab308' : tl < 75 ? '#f59e0b' : '#ef4444';
  const gvThreat = document.getElementById('gv-threat');
  gvThreat.textContent = tlLabel;
  gvThreat.style.color = tlColor;

  // Firewall load
  state.firewallLoad += (Math.random() - 0.48) * 4;
  state.firewallLoad = Math.max(10, Math.min(98, state.firewallLoad));
  updateNeedle(gaugeFirewall, state.firewallLoad);
  document.getElementById('gv-firewall').textContent = Math.round(state.firewallLoad) + '%';

  // Encryption stays mostly stable, occasional shift
  if (Math.random() < 0.005) {
    state.encryptionIdx = Math.floor(Math.random() * 3);
  }
  updateNeedle(gaugeEncryption, state.encryptionIdx + 0.5);
  document.getElementById('gv-encryption').textContent = state.encLabels[state.encryptionIdx];
}

// ═══════════════════════════════════════════════════════════
// LOG FEED
// ═══════════════════════════════════════════════════════════
const logFeed = document.getElementById('log-feed');
const ipPool = [
  '192.168.1.12', '192.168.1.45', '10.0.0.8', '172.16.0.22', '192.168.1.100',
  '10.0.0.55', '192.168.2.7', '172.16.1.33', '10.10.0.14', '192.168.1.201',
  '45.33.32.156', '8.8.8.8', '1.1.1.1', '104.26.10.78', '93.184.216.34'
];
const domains = ['cdn.example.com', 'api.internal.net', 'auth.secure.io', 'update.vendor.com', 'dns.resolver.net', 'ntp.pool.org', 'mail.corp.local'];

const logTemplates = [
  { tag: 'SCAN', cls: 'tag-scan', gen: () => `Port sweep detected from ${rIP()} → BLOCKED` },
  { tag: 'SCAN', cls: 'tag-scan', gen: () => `SYN scan on ports 22,80,443 from ${rIP()}` },
  { tag: 'AI', cls: 'tag-ai', gen: () => `Pattern match ${(85 + Math.random() * 14).toFixed(1)}% — known scanner signature` },
  { tag: 'AI', cls: 'tag-ai', gen: () => `Behavioral analysis: ${rIP()} — anomaly score ${(Math.random() * 0.4).toFixed(3)}` },
  { tag: 'AI', cls: 'tag-ai', gen: () => `Neural classifier: traffic from ${rIP()} classified NORMAL` },
  { tag: 'ALLOW', cls: 'tag-allow', gen: () => `HTTPS traffic ${rIP()} → ${rDomain()}` },
  { tag: 'ALLOW', cls: 'tag-allow', gen: () => `DNS resolution ${rDomain()} → ${rIP()}` },
  { tag: 'ALLOW', cls: 'tag-allow', gen: () => `Established connection ${rIP()}:${rPort()} ↔ ${rIP()}:443` },
  { tag: 'SHIELD', cls: 'tag-shield', gen: () => `Integrity check passed — 0 anomalies` },
  { tag: 'SHIELD', cls: 'tag-shield', gen: () => `Firewall rules refreshed — ${200 + Math.floor(Math.random() * 100)} active rules` },
  { tag: 'SHIELD', cls: 'tag-shield', gen: () => `Certificate validation: ${rDomain()} — VALID (expires ${futureDate()})` },
  { tag: 'SHIELD', cls: 'tag-shield', gen: () => `Rate limiter: ${rIP()} — ${Math.floor(Math.random() * 50 + 10)} req/s (within threshold)` },
];

const threatTemplates = [
  { tag: 'BLOCK', cls: 'tag-block', gen: () => `THREAT: Brute force attempt from ${rIP()} on port 22 — BLOCKED` },
  { tag: 'BLOCK', cls: 'tag-block', gen: () => `ALERT: SQL injection attempt detected from ${rIP()} — QUARANTINED` },
  { tag: 'BLOCK', cls: 'tag-block', gen: () => `THREAT: DDoS pattern detected — ${Math.floor(Math.random() * 5000 + 1000)} req/s from ${rIP()}` },
  { tag: 'WARN', cls: 'tag-warn', gen: () => `SUSPICIOUS: Unusual outbound traffic from ${rIP()} to ${rIP()} — MONITORING` },
  { tag: 'BLOCK', cls: 'tag-block', gen: () => `THREAT: Malware signature matched — C2 beacon from ${rIP()} — BLOCKED` },
  { tag: 'WARN', cls: 'tag-warn', gen: () => `SUSPICIOUS: Port knocking sequence detected from ${rIP()}` },
];

function rIP() { return ipPool[Math.floor(Math.random() * ipPool.length)]; }
function rDomain() { return domains[Math.floor(Math.random() * domains.length)]; }
function rPort() { return Math.floor(Math.random() * 60000 + 1024); }
function futureDate() {
  const d = new Date();
  d.setDate(d.getDate() + Math.floor(Math.random() * 365 + 30));
  return d.toISOString().split('T')[0];
}

function addLog(tag, message) {
  const now = new Date();
  const ts = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}.${String(now.getMilliseconds()).padStart(3,'0')}`;
  const tagCls = tag === 'SCAN' ? 'tag-scan' : tag === 'AI' ? 'tag-ai' : tag === 'ALLOW' ? 'tag-allow' : tag === 'BLOCK' ? 'tag-block' : tag === 'WARN' ? 'tag-warn' : 'tag-shield';

  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.innerHTML = `<span class="ts">[${ts}]</span> <span class="${tagCls}">${tag}:</span> <span class="msg">${message}</span>`;
  logFeed.appendChild(entry);

  // Keep max 80 entries
  while (logFeed.children.length > 80) {
    logFeed.removeChild(logFeed.firstChild);
  }
  logFeed.scrollTop = logFeed.scrollHeight;
}

function generateLogEntry() {
  const tmpl = logTemplates[Math.floor(Math.random() * logTemplates.length)];
  addLog(tmpl.tag, tmpl.gen());
}

function generateThreatEvent() {
  const tmpl = threatTemplates[Math.floor(Math.random() * threatTemplates.length)];
  addLog(tmpl.tag, tmpl.gen());

  // Spawn threat blip
  spawnBlip('threat');

  // Flash
  const flash = document.getElementById('threat-flash');
  flash.classList.remove('active');
  void flash.offsetWidth; // reflow
  flash.classList.add('active');

  // Make a random node threatened briefly
  const idx = Math.floor(Math.random() * state.networkNodes.length);
  state.networkNodes[idx].threat = true;
  setTimeout(() => { state.networkNodes[idx].threat = false; }, 5000);

  // Spike threat level
  state.threatLevel = Math.min(95, state.threatLevel + 15 + Math.random() * 20);

  // Add to threat list
  const list = document.getElementById('threat-list');
  const item = document.createElement('div');
  item.className = 'threat-item';
  const now = new Date();
  const ts = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  item.innerHTML = `<span class="dot threat"></span><span>${ts} — ${rIP()}</span>`;
  list.insertBefore(item, list.firstChild);
  while (list.children.length > 8) list.removeChild(list.lastChild);
}

// ═══════════════════════════════════════════════════════════
// PARTICLES
// ═══════════════════════════════════════════════════════════
const partCanvas = document.getElementById('particles-canvas');
const partCtx = partCanvas.getContext('2d');

function resizeParticles() {
  partCanvas.width = window.innerWidth * window.devicePixelRatio;
  partCanvas.height = window.innerHeight * window.devicePixelRatio;
  partCanvas.style.width = window.innerWidth + 'px';
  partCanvas.style.height = window.innerHeight + 'px';
  partCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
}

function initParticles() {
  state.particles = [];
  for (let i = 0; i < 40; i++) {
    state.particles.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      vx: (Math.random() - 0.5) * 0.3,
      vy: -0.1 - Math.random() * 0.3,
      size: 1 + Math.random() * 2,
      alpha: 0.1 + Math.random() * 0.3,
      color: Math.random() > 0.5 ? 'cyan' : 'amber',
    });
  }
}

function drawParticles() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  partCtx.clearRect(0, 0, w, h);

  state.particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    if (p.y < -10) { p.y = h + 10; p.x = Math.random() * w; }
    if (p.x < -10) p.x = w + 10;
    if (p.x > w + 10) p.x = -10;

    const c = p.color === 'cyan' ? `rgba(56, 189, 248, ${p.alpha})` : `rgba(245, 158, 11, ${p.alpha})`;
    partCtx.fillStyle = c;
    partCtx.beginPath();
    partCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    partCtx.fill();
  });
}

// ═══════════════════════════════════════════════════════════
// AI CONFIDENCE
// ═══════════════════════════════════════════════════════════
function updateConfidence() {
  state.confidence += (Math.random() - 0.48) * 0.5;
  state.confidence = Math.max(85, Math.min(99.9, state.confidence));
  document.getElementById('ai-confidence-value').textContent = state.confidence.toFixed(1) + '%';
}

// ═══════════════════════════════════════════════════════════
// EVENT SCHEDULING
// ═══════════════════════════════════════════════════════════
let lastLogTime = 0;
let lastThreatTime = 0;
let lastBlipTime = 0;
let lastGaugeTime = 0;
let lastConfidenceTime = 0;

function scheduleEvents(now) {
  // Regular log entries: every 1-3 seconds
  if (now - lastLogTime > 1000 + Math.random() * 2000) {
    generateLogEntry();
    lastLogTime = now;
  }

  // Threat events: every 30-60 seconds
  const threatInterval = state.sensitivity >= 2 ? 15000 : 35000;
  if (now - lastThreatTime > threatInterval + Math.random() * 25000) {
    generateThreatEvent();
    lastThreatTime = now;
  }

  // Spawn radar blips periodically
  if (now - lastBlipTime > 3000 + Math.random() * 5000) {
    const types = ['safe', 'safe', 'safe', 'suspicious', 'suspicious'];
    spawnBlip(types[Math.floor(Math.random() * types.length)]);
    lastBlipTime = now;
  }

  // Gauge updates
  if (now - lastGaugeTime > 500) {
    updateGauges();
    lastGaugeTime = now;
  }

  // AI confidence
  if (now - lastConfidenceTime > 2000) {
    updateConfidence();
    lastConfidenceTime = now;
  }
}

// ═══════════════════════════════════════════════════════════
// MAIN ANIMATION LOOP
// ═══════════════════════════════════════════════════════════
function mainLoop() {
  const now = Date.now();
  updateClock();
  drawRadar(now);
  drawNetwork(now);
  drawParticles();
  scheduleEvents(now);
  requestAnimationFrame(mainLoop);
}

// ═══════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════
function init() {
  resizeNetCanvas();
  resizeParticles();
  initGauges();
  initRadarBlips();
  initNetworkNodes();
  initParticles();

  // Seed initial log entries
  for (let i = 0; i < 8; i++) generateLogEntry();

  // Window resize handler
  window.addEventListener('resize', () => {
    resizeNetCanvas();
    resizeParticles();
  });

  // Initial timestamps
  const now = Date.now();
  lastLogTime = now;
  lastThreatTime = now - 20000; // trigger first threat sooner
  lastBlipTime = now;
  lastGaugeTime = now;
  lastConfidenceTime = now;

  // Kick off the first threat within 10 seconds
  setTimeout(() => generateThreatEvent(), 5000 + Math.random() * 5000);

  mainLoop();
}

init();
</script>
</body>
</html>